---
---
<div id="wrapper">

<h1>
	Inserting RTF code into a rich edit control
</h1>


<p>
  We all know how to load RTF code into a rich edit control. For example, if
  <var>RE</var> is a <var>TRichEdit</var> control, to load from a stream we'd
  use:
</p>

<div class="frame">
<!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
<pre class="pas-source">RE.Lines.LoadFromStream(Stream);</pre>
</div>

<p>
  Or, if we're really careful:
</p>

<div class="frame">
<!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
<pre class="pas-source">RE.PlainText := False;
RE.MaxLength := Stream.Size; <span class="pas-comment">// ensures long docs can display</span>
RE.Lines.LoadFromStream(Stream);</pre>
</div>

<p>
  That code overwrites the existing content. But what if we want to insert RTF
  code into some pre-existing code? Well, we need to hit the Windows API.
</p>

<p>
  We have to fill in a structure and set up some flags then pass them to the
  rich edit control via a message. We also need a call back function that
  Windows calls when it wants to read a chunk of data.
</p>

<p>
  The structure has three fields. The first takes a user-defined
  &quot;cookie&quot; that is passed to the callback function. The next field
  is an error code that the callback function passes back to the routine that
  sends the message. If this is non-zero the insertion should terminate. The
  final field is a reference to the callback function.
</p>

<p>
  I always think it's more flexible to read from streams rather than files, so
  the following example code shows how to insert RTF code from a stream:
</p>

<div class="frame">
<!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
<pre class="pas-source"><span class="pas-kwd">procedure</span> RTFInsertStream(<span class="pas-kwd">const</span> RE: TRichEdit; <span class="pas-kwd">const</span> Stream: TStream);
<span class="pas-kwd">var</span>
  EditStream: TEditStream;  <span class="pas-comment">// callback used to read inserted RTF</span>
<span class="pas-kwd">begin</span>
  RE.Lines.BeginUpdate;
  <span class="pas-kwd">try</span>
    <span class="pas-comment">// Make sure rich edit is large enough to take inserted code</span>
    RE.MaxLength := RE.MaxLength + Stream.Size;
    <span class="pas-comment">// Stream in the RTF via EM_STREAMIN message</span>
    EditStream.dwCookie := DWORD(Stream);
    EditStream.dwError := <span class="pas-hex">$0000</span>;
    EditStream.pfnCallback := @EditStreamReader;
    RE.Perform(
      EM_STREAMIN,
      SFF_SELECTION <span class="pas-kwd">or</span> SF_RTF <span class="pas-kwd">or</span> SFF_PLAINRTF, LPARAM(@EditStream)
    );
    <span class="pas-comment">// Report any errors as a bug</span>
    <span class="pas-kwd">if</span> EditStream.dwError &lt;&gt; <span class="pas-hex">$0000</span> <span class="pas-kwd">then</span>
      <span class="pas-kwd">raise</span> Exception.Create(<span class="pas-str">'RTFInsertStream: Error inserting stream'</span>);
  <span class="pas-kwd">finally</span>
    RE.Lines.EndUpdate;
  <span class="pas-kwd">end</span>;
<span class="pas-kwd">end</span>;</pre>
</div>

<p>
  First we freeze the rich edit control then make sure it has sufficient
  capacity to receive the inserted code. Next we set up the structure:
</p>

<ul>
  <li>
    The <var>dwCookie</var> field receives a reference to the stream so that
    we can access it in the callback function.
  </li>
  <li>
    We initialise <var>dwError</var> to zero to indicate no error.
  </li>
  <li>
    <var>pfnCallback</var> is set to reference the function that Windows
    calls back to.
  </li>
</ul>

<p>
  Then we send the message. The flags mean that the insertion will
  replace any current selection (<var>SFF_SELECTION</var>), we're inserting
  RTF code rather than text (<var>SF_RTF</var>) and that only keywords common
  to all languages are used (<var>SFF_PLAINRTF</var>). After the message
  call returns we check that the <var>dwError</var> field is still 0 and raise
  an exception if not. If you don't want to overwrite selections leave out the
  <var>SFF_SELECTION</var> flag.
</p>

<p>
  All that remains is to define the callback function. Here it is:
</p>


<div class="frame">
<!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
<pre class="pas-source"><span class="pas-kwd">function</span> EditStreamReader(dwCookie: DWORD; pBuff: Pointer;
  cb: LongInt; pcb: PLongInt): DWORD; <span class="pas-kwd">stdcall</span>;
<span class="pas-kwd">begin</span>
  Result := <span class="pas-hex">$0000</span>;  <span class="pas-comment">// assume no error</span>
  <span class="pas-kwd">try</span>
    pcb^ := TStream(dwCookie).Read(pBuff^, cb); <span class="pas-comment">// read data from stream</span>
  <span class="pas-kwd">except</span>
    Result := <span class="pas-hex">$FFFF</span>;  <span class="pas-comment">// indicates error to calling routine</span>
  <span class="pas-kwd">end</span>;
<span class="pas-kwd">end</span>;</pre>
</div>

<p>
  The <var>dwCookie</var> parameter contains the stream reference we prevously
  stored in the <var>TEditStream</var> structure. We cast this parameter to
  <var>TStream</var> and use it to read the stream. The <var>cb</var>
  parameter contains the number of bytes Windows wants us to provide so we
  attempt to read <var>cb</var> bytes from the stream into the buffer pointed
  to by the <var>pBuff</var> parameter. <var>pcb^</var> is set to the number
  of bytes actually read. We return zero on success or non-zero if there is an
  error. Windows passes this return value back to the caller via the
  <var>TEditStream.dwError</var> field.
</p>

<p>
  To make this code work you'll need the following <strong>uses</strong>
  clause:
</p>

<div class="frame">
<!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
<pre class="pas-source"><span class="pas-kwd">uses</span>
  Windows, Classes, ComCtrls, RichEdit, SysUtils;</pre>
</div>

<h2>
  Adapting the code
</h2>

<p>
  If you prefer to read directly from a file, you could adapt
  <var>RTFInsertStream</var> to take a file name as a parameter, open the
  required file and store its handle in <var>TEditStream.dwCookie</var>. You
  would then read the file handle in the call back function. You would also
  want to change the name of <var>RTFInsertStream</var>!
</p>
<table class="infotable">
  <tr>
    <th scope="row">Author:</th>
    <td>Peter Johnson</td>
  </tr>
  <tr>
    <th scope="row">Contributor:</th>
    <td>Peter Johnson</td>
  </tr>
  <tr>
    <th scope="row">Added:</th>
    <td>2007-10-29</td>
  </tr>
  <tr>
    <th scope="row">Last updated:</th>
    <td>
    2007-10-29</td>
  </tr>
</table>



<div id="footer">
  Copyright &copy; Peter Johnson (<a href="https://gravatar.com/delphidabbler">DelphiDabbler</a>) 2002-2020
</div> <!-- #footer -->
</div> <!-- #wrapper -->
