<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<head>
<title>How to read image pixels fast</title>
<meta http-equiv="Content-Language" content="en" />
<meta name="description" content="How to read image pixels fast" />
<meta name="keywords" content="programming, Delphi, hints, tips, hints and tips" />
<meta name="copyright" content="Copyright (c) 2002-2020 Peter D Johnson" />
<meta name="robots" content="INDEX,FOLLOW" />
<link rel="stylesheet" href="../css/main.css" />
<script type="text/javascript" src="../js/core.js"></script>
<script type="text/javascript" src="../js/offsite-win.js"></script>
<link rel="stylesheet" href="../css/tips.css" />
<link rel="stylesheet" href="../css/source.css" />
</head>
<body>
<div id="wrapper">

<h1>
	How to read image pixels fast
</h1>

<p>
  Ever needed to modify/read a bitmap? Using <var>TBitamp.Canvas.Pixels</var>
  is works just fine, but when you try it with a larger bitmap you'll notice
  the problem.
</p>

<p>
  <var>TBitmap.Canvas.Pixels</var> provides an easy way to access pixels but
  it's very slow. A way to get around this is to use <var>ScanLine()</var> to
  work on the bitmap. What do we get back? Every timem you change
  <var>TBitmap.Canvas.Pixels</var> the bitmap is redrawn. This of course
  consumes resources and valuable time. <var>ScanLine()</var> leaves this
  decision up to you, the programmer. There is a little catch here, though.
  When using <var>Canvas.Pixels[]</var> you get in return a <var>TColor</var>
  value, but when using <var>ScanLine()</var> you get back the bytes of the
  line. What does this mean? Well, you have to worry about what is Red, Green
  and Blue. With <var>Canvas.Pixels[]</var> you could've used
  <var>GetRValue()</var>, <var>GetBValue()</var> or <var>GetGValue()</var>,
  but with scan line you have to remember: each pixel is made of 3 values:
  Red, Green and Blue. You have to make sure you are reading the correct
  value.
</p>

<p>
  Look at this code:
</p>

<div class="frame">
<!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
<pre class="pas-source"><span class="pas-kwd">var</span>
  iX  : Integer;
  Line: PByteArray;
...
  Line := Image1.ScanLine[<span class="pas-num">0</span>]; <span class="pas-comment">// We are scanning the first line</span>
  iX := <span class="pas-num">0</span>;
  <span class="pas-comment">// We can't use the 'for' loop because iX could not be modified from
  // within the loop</span>
  <span class="pas-kwd">repeat</span>
    Line[iX]     := Line[iX] - <span class="pas-hex">$F</span>; <span class="pas-comment">// Red value</span>
    Line[iX + <span class="pas-num">1</span>] := Line[iX] - <span class="pas-hex">$F</span>; <span class="pas-comment">// Green value</span>
    Line[iX + <span class="pas-num">2</span>] := Line[iX] - <span class="pas-hex">$F</span>; <span class="pas-comment">// Blue value</span>
    Inc(iX, <span class="pas-num">3</span>); <span class="pas-comment">// Move to next pixel</span>
  <span class="pas-kwd">until</span> iX &gt; (Image1.Width - <span class="pas-num">1</span>) * <span class="pas-num">3</span>;</pre>
</div>

<p>
  As you can see you each color is now made of 3 values, so if you
  miscalculate the next trio (may happen) you will be editing/reading garbage.
  Not only will you mix up Red, Green and Blue but you will be reading values
  from two neighbouring pixels.
</p>

<p>
  Here's code that show how to reads the Red and Blue values and switched
  them.
</p>

<div class="frame">
<!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
<pre class="pas-source"><span class="pas-kwd">var</span>
  btTemp: Byte; <span class="pas-comment">// Used to swap colors</span>
  iY, iX: Integer;
  Line  : PByteArray;
...
  <span class="pas-kwd">for</span> iY := <span class="pas-num">0</span> <span class="pas-kwd">to</span> Image1.Height - <span class="pas-num">1</span> <span class="pas-kwd">do</span> <span class="pas-kwd">begin</span>
    Line := Image1.ScanLine[iY]; <span class="pas-comment">// Read the current line</span>
    <span class="pas-kwd">repeat</span>
      btSwap       := Line[iX];     <span class="pas-comment">// Save red value</span>
      Line[iX]     := Line[iX + <span class="pas-num">2</span>]; <span class="pas-comment">// Switch red with blue</span>
      Line[iX + <span class="pas-num">2</span>] := btSwap;       <span class="pas-comment">// Switch blue with previously saved red</span>
      <span class="pas-comment">// Line[iX + 1] - Green value, not used in example</span>
      Inc(iX, <span class="pas-num">3</span>);
    <span class="pas-kwd">until</span> iX &gt; (Image1.Width - <span class="pas-num">1</span>) * <span class="pas-num">3</span>;
  <span class="pas-kwd">end</span>;
  Image1.Invalidate; <span class="pas-comment">// Redraw bitmap after everything's done</span></pre>
</div>

<p>
  The example is quite simple yet it should explain the usage of this
  function.
</p>

<p class="callout">
  <strong>Note:</strong> This code only works with 24 bit pixel format bitmaps.
  You should ensure the bitmap's <var>PixelFormat</var> property is set to
  <var>pf24bit</var>.
</p>
<table class="infotable">
  <tr>
    <th scope="row">Author:</th>
    <td>Unknown</td>
  </tr>
  <tr>
    <th scope="row">Added:</th>
    <td>2007-06-02</td>
  </tr>
  <tr>
    <th scope="row">Last updated:</th>
    <td>
    2011-01-16</td>
  </tr>
</table>



<div id="footer">
  Copyright &copy; Peter Johnson (<a href="https://gravatar.com/delphidabbler">DelphiDabbler</a>) 2002-2020
</div> <!-- #footer -->
</div> <!-- #wrapper -->
</body>
</html>
