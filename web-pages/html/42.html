<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Fast string file searching</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<meta http-equiv="Content-Language" content="en" />
<meta name="description" content="Fast string file searching" />
<meta name="keywords" content="programming, Delphi, hints, tips, hints and tips" />
<meta name="copyright" content="Copyright (c) 2002-2020 Peter D Johnson" />
<meta name="robots" content="INDEX,FOLLOW" />
<link rel="stylesheet" href="../css/main.css" />
<link rel="stylesheet" href="../css/main-multicol-scr.css" media="screen" />
<link rel="stylesheet" href="../css/main-2col-scr.css" media="screen" />
<script type="text/javascript" src="../js/core.js"></script>
<script type="text/javascript" src="../js/offsite-win.js"></script>
<link rel="stylesheet" href="../css/tips.css" />
<link rel="stylesheet" href="../css/source.css" />
</head>
<body>
<div id="wrapper">

<h1>
	Fast string file searching
</h1>

<div class="frame">
<!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
<pre class="pas-source"><span class="pas-kwd">function</span> StringInFile(strFind, strFileName: <span class="pas-kwd">string</span>): boolean;
<span class="pas-kwd">const</span>
  BUFSIZE = <span class="pas-num">8192</span>;
<span class="pas-kwd">var</span>
  fstm: TFileStream;
  numread: Longint;
  buffer: <span class="pas-kwd">array</span> [<span class="pas-num">0</span>..BUFSIZE-<span class="pas-num">1</span>] <span class="pas-kwd">of</span> char;
  szFind: <span class="pas-kwd">array</span> [<span class="pas-num">0</span>..<span class="pas-num">255</span>] <span class="pas-kwd">of</span> char;
  found: boolean;
<span class="pas-kwd">begin</span>
  StrPCopy(szFind, strFind);
  found := False;
  fstm := TFileStream.Create(strFileName, fmOpenRead);
  <span class="pas-kwd">repeat</span>
    numread := fstrm.<span class="pas-kwd">Read</span>(Buffer, BUFSIZE);
    <span class="pas-kwd">if</span> BMFind(szFind, Buffer, numread) &gt;= <span class="pas-num">0</span> <span class="pas-kwd">then</span>
      found := True
    <span class="pas-kwd">else</span> <span class="pas-kwd">if</span> numread = BUFSIZE <span class="pas-kwd">then</span> <span class="pas-comment">// more to scan</span>
      fstm.Position := fstmPosition - (Length(strFind)-<span class="pas-num">1</span>);
  <span class="pas-kwd">until</span> found <span class="pas-kwd">or</span> (numread &lt; BUFSIZE);
  fstm.Free;
  Result := found;
<span class="pas-kwd">end</span>;</pre>
</div>

<p>
  The reason for backing up <var>fstm.Position</var> by nearly the length of
  <var>strFind</var> is in case <var>strFind</var> crosses buffer boundaries.
</p>

<p>
  The <var>BMFind</var> function used above is a Boyer-Moore search as shown
  below. This is the fastest string search known.
</p>

<div class="frame">
<!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
<pre class="pas-source"><span class="pas-kwd">function</span> BMFind(szSubStr, buf: PChar; iBufSize: integer): integer;
  <span class="pas-comment">{ Returns -1 if substring not found,</span>
<span class="pas-comment">  or zero-based index into buffer if substring found }</span>
<span class="pas-kwd">var</span>
  iSubStrLen: integer;
  skip: <span class="pas-kwd">array</span> [char] <span class="pas-kwd">of</span> integer;
  found: boolean;
  iMaxSubStrIdx: integer;
  iSubStrIdx: integer;
  iBufIdx: integer;
  iScanSubStr: integer;
  mismatch: boolean;
  iBufScanStart: integer;
  ch: char;
<span class="pas-kwd">begin</span>
  <span class="pas-comment">{ Initialisations }</span>
  found := False;
  Result := -<span class="pas-num">1</span>;
  <span class="pas-comment">{ Check if trivial scan for empty string }</span>
  iSubStrLen := StrLen(szSubStr);
  <span class="pas-kwd">if</span> iSubStrLen = <span class="pas-num">0</span> <span class="pas-kwd">then</span>
  <span class="pas-kwd">begin</span>
    Result := <span class="pas-num">0</span>;
    Exit
  <span class="pas-kwd">end</span>;

  iMaxSubStrIdx := iSubStrLen - <span class="pas-num">1</span>;
  <span class="pas-comment">{ Initialise the skip table }</span>
  <span class="pas-kwd">for</span> ch := Low(skip) <span class="pas-kwd">to</span> High(skip) <span class="pas-kwd">do</span> skip[ch] := iSubStrLen;
  <span class="pas-kwd">for</span> iSubStrIdx := <span class="pas-num">0</span> <span class="pas-kwd">to</span> (iMaxSubStrIdx - <span class="pas-num">1</span>) <span class="pas-kwd">do</span>
    skip[szSubStr[iSubStrIdx]] := iMaxSubStrIdx - iSubStrIdx;

  <span class="pas-comment">{ Scan the buffer, starting comparisons at the end of the substring }</span>
  iBufScanStart := iMaxSubStrIdx;
  <span class="pas-kwd">while</span> (<span class="pas-kwd">not</span> found) <span class="pas-kwd">and</span> (iBufScanStart &lt; iBufSize) <span class="pas-kwd">do</span>
  <span class="pas-kwd">begin</span>
    iBufIdx := iBufScanStart;
    iScanSubStr := iMaxSubStrIdx;
    <span class="pas-kwd">repeat</span>
      mismatch := (szSubStr[iScanSubStr] &lt;&gt; buf[iBufIdx]);
      <span class="pas-kwd">if</span> <span class="pas-kwd">not</span> mismatch <span class="pas-kwd">then</span>
        <span class="pas-kwd">if</span> iScanSubStr &gt; <span class="pas-num">0</span> <span class="pas-kwd">then</span>
        <span class="pas-kwd">begin</span> <span class="pas-comment">// more characters to scan</span>
          Dec(iBufIdx); Dec(iScanSubStr)
        <span class="pas-kwd">end</span>
      <span class="pas-kwd">else</span>
        found := True;
    <span class="pas-kwd">until</span> mismatch <span class="pas-kwd">or</span> found;
    <span class="pas-kwd">if</span> found <span class="pas-kwd">then</span>
      Result := iBufIdx
    <span class="pas-kwd">else</span>
      iBufScanStart := iBufScanStart + skip[buf[iBufScanStart]];
  <span class="pas-kwd">end</span>;
<span class="pas-kwd">end</span>;</pre>
</div>

<p>
  I have included a <var>wholeword_only</var> flag in the <var>BMFind</var>
  below. This confirms or rejects the <var>found</var> result, and will cause
  the loop to keep searching if match is rejected.
</p>

<div class="frame">
<!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
<pre class="pas-source"><span class="pas-kwd">function</span> BMFind(szSubStr, buf: PChar; iBufSize: integer;
  wholeword_only: boolean): integer;
  <span class="pas-comment">{ Returns -1 if substring not found,</span>
<span class="pas-comment">  or zero-based index into buffer if substring found }</span>
<span class="pas-kwd">var</span>
  iSubStrLen: integer;
  skip: <span class="pas-kwd">array</span> [char] <span class="pas-kwd">of</span> integer;
  found: boolean;
  iMaxSubStrIdx: integer;
  iSubStrIdx: integer;
  iBufIdx: integer;
  iScanSubStr: integer;
  mismatch: boolean;
  iBufScanStart: integer;
  ch: char;
<span class="pas-kwd">begin</span>
  found := False;
  Result := -<span class="pas-num">1</span>;
  iSubStrLen := StrLen(szSubStr);
  <span class="pas-kwd">if</span> iSubStrLen = <span class="pas-num">0</span> <span class="pas-kwd">then</span>
  <span class="pas-kwd">begin</span>
    Result := <span class="pas-num">0</span>;
    Exit
  <span class="pas-kwd">end</span>;

  iMaxSubStrIdx := iSubStrLen - <span class="pas-num">1</span>;
  <span class="pas-comment">{ Initialise the skip table }</span>
  <span class="pas-kwd">for</span> ch := Low(skip) <span class="pas-kwd">to</span> High(skip) <span class="pas-kwd">do</span> skip[ch] := iSubStrLen;
    <span class="pas-kwd">for</span> iSubStrIdx := <span class="pas-num">0</span> <span class="pas-kwd">to</span> (iMaxSubStrIdx - <span class="pas-num">1</span>) <span class="pas-kwd">do</span>
      skip[szSubStr[iSubStrIdx]] := iMaxSubStrIdx - iSubStrIdx;

  <span class="pas-comment">{ Scan the buffer, starting comparisons at the end of the substring }</span>
  iBufScanStart := iMaxSubStrIdx;
  <span class="pas-kwd">while</span> (<span class="pas-kwd">not</span> found) <span class="pas-kwd">and</span> (iBufScanStart &lt; iBufSize) <span class="pas-kwd">do</span>
  <span class="pas-kwd">begin</span>
    iBufIdx := iBufScanStart;
    iScanSubStr := iMaxSubStrIdx;
    <span class="pas-kwd">repeat</span>
      mismatch := (szSubStr[iScanSubStr] &lt;&gt; buf[iBufIdx]);
      <span class="pas-kwd">if</span> <span class="pas-kwd">not</span> mismatch <span class="pas-kwd">then</span>
        <span class="pas-kwd">if</span> iScanSubStr &gt; <span class="pas-num">0</span> <span class="pas-kwd">then</span>
        <span class="pas-kwd">begin</span> <span class="pas-comment">// more characters to scan</span>
          Dec(iBufIdx); Dec(iScanSubStr)
        <span class="pas-kwd">end</span>
        <span class="pas-kwd">else</span>
          found := True;
    <span class="pas-kwd">until</span> mismatch <span class="pas-kwd">or</span> found;
    <span class="pas-kwd">if</span> found <span class="pas-kwd">and</span> wholeword_only <span class="pas-kwd">then</span>
    <span class="pas-kwd">begin</span>
      <span class="pas-kwd">if</span> (iBufIdx &gt; <span class="pas-num">0</span>) <span class="pas-kwd">then</span>
        found := <span class="pas-kwd">not</span> IsCharAlpha(buf[iBufIdx - <span class="pas-num">1</span>]);
      <span class="pas-kwd">if</span> found <span class="pas-kwd">then</span>
        <span class="pas-kwd">if</span> iBufScanStart &lt; (iBufSize - <span class="pas-num">1</span>) <span class="pas-kwd">then</span>
          found := <span class="pas-kwd">not</span> IsCharAlpha(buf[iBufScanStart + <span class="pas-num">1</span>]);
    <span class="pas-kwd">end</span>;
    <span class="pas-kwd">if</span> found <span class="pas-kwd">then</span>
      Result := iBufIdx
    <span class="pas-kwd">else</span>
      iBufScanStart := iBufScanStart + skip[buf[iBufScanStart]];
  <span class="pas-kwd">end</span>;
<span class="pas-kwd">end</span>;</pre>
</div>

<p>
  Obviously you'll be tempted to increase <var>BUFSIZE</var> on the assumption
  that it will improve performance. My experience is that it does not, and
  that 8K is pretty optimum.
</p>

<table class="infotable">
  <tr>
    <th scope="row">Author:</th>
    <td>Unknown</td>
  </tr>
  <tr>
    <th scope="row">Added:</th>
    <td>2007-06-11</td>
  </tr>
  <tr>
    <th scope="row">Last updated:</th>
    <td>
    2007-06-11</td>
  </tr>
</table>



<div id="footer">
  Copyright &copy; Peter Johnson (<a href="https://gravatar.com/delphidabbler">DelphiDabbler</a>) 2002-2020
</div> <!-- #footer -->
</div> <!-- #wrapper -->
</body>
</html>
